# -*- coding: utf-8 -*-
"""single sample face recognition using NN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kNWKr1XVzuXEve_cWh7w2BdHXaa8JoPc

در بخش content دو فولدر خالی به نام های temp1 ,temp2 بسازید

RUN!
"""

import numpy as np
!pip install pillow
import matplotlib.pyplot as plt
import numpy as np
!pip install Image
import cv2
import os
from PIL import Image
!pip install image_slicer
import image_slicer
from PIL import ImageDraw, ImageFont
import os
import PIL
from sklearn.datasets import load_sample_image
from sklearn.feature_extraction import image
from PIL import Image
from numpy import linalg 
from os import listdir
from matplotlib import image
from skimage import color

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

#Visualization
import matplotlib.pyplot as plt

#Machine Learning
from sklearn.model_selection import train_test_split
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn import metrics
import tensorflow as tf
#System
import os
print(os.listdir("../content"))

from matplotlib.pyplot import imshow

import warnings
warnings.filterwarnings('ignore')
print("Warnings ignored!!")

data=np.load("../content/olivetti_faces.npy")
target=np.load("/content/olivetti_faces_target.npy")

print("There are {} images in the dataset".format(len(data)))
print("There are {} unique targets in the dataset".format(len(np.unique(target))))
print("Size of each image is {}x{}".format(data.shape[1],data.shape[2]))
print("Pixel values were scaled to [0,1] interval. e.g:{}".format(data[0][0,:4]))

print("unique target number:",np.unique(target))

def show_40_distinct_people(images, unique_ids):
    #Creating 4X10 subplots in  18x9 figure size
    fig, axarr=plt.subplots(nrows=4, ncols=10, figsize=(18, 9))
    #For easy iteration flattened 4X10 subplots matrix to 40 array
    axarr=axarr.flatten()
    
    #iterating over user ids
    for unique_id in unique_ids:
        image_index=unique_id*10
        axarr[unique_id].imshow(images[image_index], cmap='gray')
        axarr[unique_id].set_xticks([])
        axarr[unique_id].set_yticks([])
        axarr[unique_id].set_title("face id:{}".format(unique_id))
    plt.suptitle("There are 40 distinct people in the dataset")

show_40_distinct_people(data, np.unique(target))

def show_10_faces_of_n_subject(images, subject_ids):
    cols=10# each subject has 10 distinct face images
    rows=(len(subject_ids)*10)/cols #
    rows=int(rows)
    
    fig, axarr=plt.subplots(nrows=rows, ncols=cols, figsize=(18,9))
    #axarr=axarr.flatten()
    
    for i, subject_id in enumerate(subject_ids):
        for j in range(cols):
            image_index=subject_id*10 + j
            axarr[i,j].imshow(images[image_index], cmap="gray")
            axarr[i,j].set_xticks([])
            axarr[i,j].set_yticks([])
            axarr[i,j].set_title("face id:{}".format(subject_id))

#You can playaround subject_ids to see other people faces
show_10_faces_of_n_subject(images=data, subject_ids=[0,5, 21, 24, 36])

#برداشتن دیتا و تارگت از دیتاست
X = data
y = target

print(np.shape(y))

#عکس اول هر فرد در مجموعه ترین و بقیه در مجموعه تست
t=[]
tr=[]
for i in range(0,399):
  if(i%10 ==0):
    tr.append(i)
  elif(i%10 !=0):
    t.append(i)


trImages=X[tr]
trLabels=y[tr]
tImages=X[t]
tLabels=y[t]

"""دیدن عکس اصلی... در دیتاست و حین محاسبات فشرده شده برای همین اونشکلی میبین ولی همینه در اصل"""

im = Image.fromarray(trImages[0],'L')
im.save('/content/a.jpg')
imshow(trImages[1], cmap='gray')

#توابع مورد نیاز برای پیاده سازی متریک فاصله ما


#تابع سگمنت کردن هر دو عکس دریافتی
#تعداد سگمنتهای دو عکس باید مساوی باشد و بسته به سلیقتون باید در خط کد اسلایسر وارد کنید.
def slice_x_y(z1,z2):
  im = Image.fromarray(z1,'L')
  im.save("/content/temp1/z1.png")
  tiles = image_slicer.slice("/content/temp1/z1.png", 16, save=False)
  image_slicer.save_tiles(tiles, directory='/content/temp1')
  os.remove("/content/temp1/z1.png")

  im2 = Image.fromarray(z2, "L")
  #im2=im2.convert("L")
  im2.save("/content/temp2/z2.png")
  tiles2 = image_slicer.slice("/content/temp2/z2.png", 16, save=False)
  image_slicer.save_tiles(tiles2, directory='/content/temp2')
  os.remove("/content/temp2/z2.png")

#محاسبه فرمول 14 مقاله
def  dissz(z1, z2,p,q):
  z1t=np.asarray(z1).T
  z2t=np.asarray(z2).T
  a=1/(2*p-1)
  mul=z1t.dot(z1)
  mul2=z2t.dot(z2)

  r=a*mul+a*mul2
  landar=linalg.eigvals(r)
  t=0
  for j in range(0,q) :
    t=t+pow((landar[j]-0.5),2)
  dz=(4/q)*t
  return dz


#محاسبه فرمول 15 مقاله
def  disszt(z1, z2,p,q):
  z1t=np.asarray(z1).T
  z2t=np.asarray(z2).T
  a=1/(2*q-1)
  mul=z1.dot(z1t)
  mul2=z2.dot(z2t)

  rt=a*mul+a*mul2
  landart=linalg.eigvals(rt)
  tt=0
  for j in range(0,p) :
    tt=tt+pow((landart[j]-0.5),2)
  dzt=(4/p)*tt
  return dzt  


 #محاسبه فرمول 16 مقاله 
def diss(z1,z2, p, q):
  d=dissz(z1,z2,p,q)
  dt=disszt(z1,z2,p,q)
  dis=(d+dt)/2
  return dis


#متریک ساخته نهایی
#سایز سگمنتهای حاصل را باید طول و عرضشان را در خط کد سه تا مانده به آخر وارد کنید. این پارامتر تابع 16 است 
def mymetric(a,b):
  slice_x_y(a,b)
  folder_pathx = (r'/content/temp1')
  folder_pathy = (r'/content/temp2')
  loaded_imagesx = list()
  for filename in listdir(folder_pathx):
    img_datax = color.rgb2gray(image.imread(folder_pathx +"/"+ filename))
    loaded_imagesx.append(img_datax)
  loaded_imagesy = list()
  for filename in listdir(folder_pathy):
    img_datay = color.rgb2gray(image.imread(folder_pathy +"/"+ filename))
    loaded_imagesy.append(img_datay)
  dis=[]
  for imagest in loaded_imagesx:
    for imagestr in loaded_imagesy:
      dis.append(diss(imagest, imagestr, 16, 16))
  dissf=np.mean(dis)   
  return dissf

# اگر میخواهید که به صورت دستی عدم شباهت دو عکس دلخواه را بر حسب متریک ساخته شده بیابید اجرا کنید
#در لوپ ساخته شده میتوانید فاسله هر نمونه تست با همه ترین ها را ببینید.
# اگر فقط میخواهید برنامه اصلی را اجرا کنید از این بخش صرف نظر کنید.
z1=np.asarray(trImages[2])
z2=np.asarray(tImages[1])

mymetric(z1,z2)

for iTeI in range(1,50):
  print(arrayL2Norm)# store distance of a test image from all train images
  arrayL2Norm = np.array([]) 
  for jTrI in range(8,40):  
    l2norm = mymetric(np.asarray(trImages[jTrI]), np.asarray(tImages[iTeI])) # distance between two images; 255 is max. pixel value ==> normalization   
    arrayL2Norm = np.append(arrayL2Norm, l2norm)

arrayL2Norm

numTrainImages = np.shape(trLabels)[0] # so many train images
numTestImages = np.shape(tLabels)[0] # so many test images
print(numTestImages)
print(numTrainImages)

#الگوریتم nn
#متریک:مدل ما
#نتایجی که میبیند حاصل از اجرای این قطعه در حالیست که کدهای توابع متریک در حالت سایز پچ 2*2 تنظیم شده است

paramk = 1 # parameter k of k-nearest neighbors
numTrainImages = np.shape(trLabels)[0] # so many train images
numTestImages = np.shape(tLabels)[0] # so many test images
numErrs=0
arrayKNNLabels = np.array([])
for iTeI in range(0,numTestImages):
  atestfromalltrainarray = np.array([]) # store distance of a test image from all train images
  for jTrI in range(numTrainImages):  
    distance = mymetric(np.asarray(trImages[jTrI]), np.asarray(tImages[iTeI])) # distance between two images; 255 is max. pixel value ==> normalization   
    atestfromalltrainarray = np.append(atestfromalltrainarray, distance)
    
  sIndex = np.argsort(atestfromalltrainarray) # sorting distance and returning indices that achieves sort
  
  kLabels = trLabels[sIndex[0:paramk]] # choose first k labels  
  (values, counts) = np.unique(kLabels, return_counts=True) # find unique labels and their counts
  arrayKNNLabels = np.append(arrayKNNLabels, values[np.argmax(counts)])
  print(atestfromalltrainarray[sIndex[0]], kLabels, arrayKNNLabels[-1], tLabels[iTeI])
  if arrayKNNLabels[-1] != tLabels[iTeI]:
    numErrs += 1
    print(numErrs,"/",iTeI)
print("# Classification Errors= ", numErrs, "% accuracy= ", 100.*(numTestImages-numErrs)/numTestImages)

"""***`اضافات`***"""

#متریک: اقلیدسی
paramk = 1 # parameter k of k-nearest neighbors
numTrainImages = np.shape(trLabels)[0] # so many train images
numTestImages = np.shape(tLabels)[0] # so many test images
numErrs=0
arrayKNNLabels = np.array([])
for iTeI in range(1,numTestImages):
  arrayL2Norm = np.array([]) # store distance of a test image from all train images
  for jTrI in range(numTrainImages):  
    l2norm = np.sum(((trImages[jTrI]-tImages[iTeI])/255.0)**2)**(0.5) # distance between two images; 255 is max. pixel value ==> normalization   
    arrayL2Norm = np.append(arrayL2Norm, l2norm)
    
  sIndex = np.argsort(arrayL2Norm) # sorting distance and returning indices that achieves sort
  
  kLabels = trLabels[sIndex[0:paramk]] # choose first k labels  
  (values, counts) = np.unique(kLabels, return_counts=True) # find unique labels and their counts
  arrayKNNLabels = np.append(arrayKNNLabels, values[np.argmax(counts)])
  print(arrayL2Norm[sIndex[0]], kLabels, arrayKNNLabels[-1], tLabels[iTeI])
  if arrayKNNLabels[-1] != tLabels[iTeI]:
      numErrs += 1
      print(numErrs,"/",iTeI) 
print("# Classification Errors= ", numErrs, "% accuracy= ", 100.*(numTestImages-numErrs)/numTestImages)

#تنظیم شروع نمونه های اموزشی از هشت
#سایز پچ ها 2*2
paramk = 1 # parameter k of k-nearest neighbors
numTrainImages = np.shape(trLabels)[0] # so many train images
numTestImages = np.shape(tLabels)[0] # so many test images
numErrs=0
arrayKNNLabels = np.array([])
for iTeI in range(1,numTestImages):
  arrayL2Norm = np.array([]) # store distance of a test image from all train images
  for jTrI in range(8,40):  
    l2norm = mymetric(np.asarray(trImages[jTrI]), np.asarray(tImages[iTeI])) # distance between two images; 255 is max. pixel value ==> normalization   
    arrayL2Norm = np.append(arrayL2Norm, l2norm)
    
  sIndex = np.argsort(arrayL2Norm) # sorting distance and returning indices that achieves sort
  
  kLabels = trLabels[sIndex[0:paramk]] # choose first k labels  
  (values, counts) = np.unique(kLabels, return_counts=True) # find unique labels and their counts
  arrayKNNLabels = np.append(arrayKNNLabels, values[np.argmax(counts)])
  print(arrayL2Norm[sIndex[0]], kLabels, arrayKNNLabels[-1], tLabels[iTeI])
  if arrayKNNLabels[-1] != tLabels[iTeI]:
      numErrs += 1
      print(numErrs,"/",iTeI) 
print("# Classification Errors= ", numErrs, "% accuracy= ", 100.*(numTestImages-numErrs)/numTestImages)

#میتوانید متریک ما را روی هر دو عکس دلخواهتان امتحان کنید.
from PIL import Image

#x1= color.rgb2gray(cv2.imread("/content/Photo.jpg",0))
#x2=color.rgb2gray(cv2.imread("/content/amir.jpg",0))
#im = Image.fromarray(x2,'L')
#im.save('/content/a.jpg')

#print(np.shape(x2))
print(mymetric(x1,x2),mymetric(x1,x1))

#متریک مدل ما با سایز پچ 4*4
paramk = 1 # parameter k of k-nearest neighbors
numTrainImages = np.shape(trLabels)[0] # so many train images
numTestImages = np.shape(tLabels)[0] # so many test images
numErrs=0
arrayKNNLabels = np.array([])
for iTeI in range(0,numTestImages):
  atestfromalltrainarray = np.array([]) # store distance of a test image from all train images
  for jTrI in range(numTrainImages):  
    distance = mymetric(np.asarray(trImages[jTrI]), np.asarray(tImages[iTeI])) # distance between two images; 255 is max. pixel value ==> normalization   
    atestfromalltrainarray = np.append(atestfromalltrainarray, distance)
    
  sIndex = np.argsort(atestfromalltrainarray) # sorting distance and returning indices that achieves sort
  
  kLabels = trLabels[sIndex[0:paramk]] # choose first k labels  
  (values, counts) = np.unique(kLabels, return_counts=True) # find unique labels and their counts
  arrayKNNLabels = np.append(arrayKNNLabels, values[np.argmax(counts)])
  print(atestfromalltrainarray[sIndex[0]], kLabels, arrayKNNLabels[-1], tLabels[iTeI])
  if arrayKNNLabels[-1] != tLabels[iTeI]:
    numErrs += 1
    print(numErrs,"/",iTeI)
print("# Classification Errors= ", numErrs, "% accuracy= ", 100.*(numTestImages-numErrs)/numTestImages)